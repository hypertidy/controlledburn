<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>controlledburn-journey • controlledburn</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="controlledburn-journey">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">


    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">controlledburn</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles

    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/controlledburn-journey.html">controlledburn-journey</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/hypertidy/controlledburn/" class="external-link">
    <span class="fab fa-github fa-lg"></span>

  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->



      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>controlledburn-journey</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/hypertidy/controlledburn/blob/main/vignettes/controlledburn-journey.Rmd" class="external-link"><code>vignettes/controlledburn-journey.Rmd</code></a></small>
      <div class="hidden name"><code>controlledburn-journey.Rmd</code></div>

    </div>

    
    
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/hypertidy/controlledburn" class="external-link">controlledburn</a></span><span class="op">)</span></span></code></pre></div>
<div class="section level2">
<h2 id="rasterizing-polygons-without-pixels-the-controlledburn-story">Rasterizing polygons without pixels: the controlledburn story<a class="anchor" aria-label="anchor" href="#rasterizing-polygons-without-pixels-the-controlledburn-story"></a>
</h2>
<p>When you rasterize a polygon onto a grid, what are you actually
computing? At its core, you’re answering two questions for every cell:
<em>is this cell inside the polygon?</em> and <em>how much of this cell
does the polygon cover?</em> The first question gives you a binary mask.
The second gives you exact coverage fractions — the kind of sub-pixel
precision that makes zonal statistics accurate.</p>
<p>The standard approach allocates a dense matrix the size of the grid,
fills it with zeros, walks the polygon edges to compute boundary cell
coverage, then flood-fills the interior. For a 32,000 × 16,000 grid —
not unusual for continental-scale work — that’s 500 million cells, about
2 GB of floats, most of which are either 0.0 (outside) or 1.0 (inside).
The interesting information lives almost entirely on the boundary.</p>
<p>controlledburn takes a different path. It computes exact coverage
fractions for every boundary cell, classifies interior cells by winding
number, and returns two small tables: run-length encoded interior spans
and individually weighted boundary cells. No dense matrix is ever
allocated. Memory is O(perimeter), not O(area). For that 32K × 16K grid,
the output is about 50 MB instead of 2 GB.</p>
<p>This post traces how controlledburn got here — through exactextract’s
elegant geometry engine, a series of prototype packages, and a scanline
algorithm that replaces flood fill with winding arithmetic.</p>
<div class="section level3">
<h3 id="inside-exactextract">Inside exactextract<a class="anchor" aria-label="anchor" href="#inside-exactextract"></a>
</h3>
<p>The exactextract C++ library, written by Daniel Baston at ISciences,
is the algorithmic core behind the exactextractr R package and its
Python counterpart. It computes exact polygon-grid coverage fractions —
not sampling, not approximation, but analytical computation of the area
of intersection between each polygon and each grid cell it touches.</p>
<p>The algorithm works by walking polygon ring edges through the grid,
cell by cell. When an edge enters a cell, exactextract records the entry
point and side. When it exits, it records the exit point and side. The
polygon fragment inside the cell — a trapezoid, triangle, or more
complex shape — is bounded by the edge path on one side and the cell
perimeter on the other. The area of this shape is the coverage
fraction.</p>
<p>The key abstraction is the <code>Cell</code> class. Each cell
maintains a list of <em>traversals</em> — the paths that polygon edges
trace through it. After all edges have been walked, the cell computes
its coverage fraction from the geometry of those traversals. For cells
with a single traversal (the common case for boundary cells), this is a
simple polygon area calculation. For cells with multiple traversals
(where several edges pass through the same cell), exactextract uses
<code>left_hand_area()</code> — a chain-chasing algorithm that links
traversal endpoints around the cell perimeter to form closed polygons,
then sums their signed areas.</p>
<p>Interior cells — those completely inside the polygon — are classified
by flood fill. Starting from a seed cell known to be inside, the
algorithm fills outward until it hits boundary cells. This is the
O(area) step: every interior cell must be visited and written.</p>
<p>The R package wraps this in a per-feature extraction loop. For each
polygon, it computes a <code>RasterCellIntersection</code> over a
subgrid (the polygon’s bounding box clipped to the raster extent), then
runs zonal statistics against raster values weighted by coverage
fractions. The output is heavily oriented toward summary statistics —
means, sums, quantiles — rather than the raw spatial intersection
data.</p>
</div>
<div class="section level3">
<h3 id="the-gap">The gap<a class="anchor" aria-label="anchor" href="#the-gap"></a>
</h3>
<p>There’s a valuable intermediate product that neither exactextractr
nor any other R package exposes directly: the raw polygon-grid
intersection itself, as a sparse data structure. Not a dense matrix, not
summary statistics, but the set of (cell, coverage_fraction, polygon_id)
triples that describes exactly which cells each polygon touches and by
how much.</p>
<p>This is what I’ve been calling a <em>polygon-grid intersection
database</em> — a pluripotent intermediate from which dense rasters,
zonal statistics, polygon overlays, and weighted extractions can all be
derived on demand. The key property is that it’s compact (proportional
to boundary length, not grid area) and lossless (you can reconstruct the
exact dense matrix from it).</p>
<p>The original controlledburn package, derived from Noam Ross’s
fasterize, got partway there. It used the Wylie et al. scanline
algorithm from fasterize to compute binary in/out classification without
materializing a raster, returning (row, start_col, end_col, geometry_id)
tuples. Fast and compact, but no coverage fractions — every boundary
cell was classified as either fully in or fully out based on cell-centre
containment.</p>
<p>The question was: could we get exactextract’s precision without its
dense matrix?</p>
</div>
<div class="section level3">
<h3 id="gridburn-proving-the-vendor">gridburn: proving the vendor<a class="anchor" aria-label="anchor" href="#gridburn-proving-the-vendor"></a>
</h3>
<p>The first step was gridburn — a proof of concept that vendored the
exactextract C++ algorithm into a standalone R package. The goal was
simple: call <code>raster_cell_intersection()</code> the same way
exactextractr does, but instead of feeding the result into zonal
statistics, compress the dense coverage matrix into the sparse two-table
format.</p>
<p>Vendoring meant extracting the algorithmic core from exactextract’s
~50 source files — just the geometry engine (Cell, Box, Grid, traversal
areas, flood fill, GEOS utilities) without the GDAL I/O, statistics
framework, or processing pipeline. About 13 C++ files, compiled directly
against libgeos for GEOS access without a system dependency.</p>
<p>gridburn’s <code><a href="../reference/burn_sparse.html">burn_sparse()</a></code> function proved the concept:
exact coverage fractions in a compact format. A
<code>dense_to_sparse.h</code> header walks the dense matrix output by
<code>raster_cell_intersection()</code>, classifying each cell as
interior (coverage ≈ 1.0, emitted as part of a run), boundary (0 &lt;
coverage &lt; 1, emitted individually), or exterior (skipped). The
output: two data frames, typically 100-1000× smaller than the dense
matrix.</p>
<p>But gridburn still allocated the dense matrix internally. For a 256K
× 512K grid, that’s 131 billion cells — the matrix just existed briefly
before being compressed. The O(area) flood fill was still running. For
large grids with simple polygons, most of the computation was wasted on
interior cells that would all be 1.0.</p>
</div>
<div class="section level3">
<h3 id="the-key-insight">The key insight<a class="anchor" aria-label="anchor" href="#the-key-insight"></a>
</h3>
<p>The exactextract algorithm already does O(perimeter) work to compute
boundary cell coverage fractions. The expensive part is the flood fill
that classifies interior cells. But interior classification is exactly
what a scanline rasterizer does — by counting edge crossings per row,
you know which spans are inside without ever touching interior
cells.</p>
<p>The insight: keep exactextract’s per-cell coverage computation for
boundary cells, replace the flood fill with a scanline winding-count
sweep.</p>
<p>This isn’t a new idea in computer graphics — winding-number
classification is textbook. What makes it non-trivial here is combining
it with exact coverage fractions. The winding count tells you which
cells are interior (coverage = 1.0) and the exactextract traversal
machinery tells you the exact fraction for boundary cells. The two
computations share the same edge walk but produce different outputs.</p>
</div>
<div class="section level3">
<h3 id="denseburn-the-refactor">denseburn: the refactor<a class="anchor" aria-label="anchor" href="#denseburn-the-refactor"></a>
</h3>
<p>The implementation went through six items, each building on the
last.</p>
<p><strong>Item 1: Scanline winding sweep.</strong> The core algorithm.
Walk each polygon ring through the grid using exactextract’s
<code>Cell</code> class, collecting traversals per cell. Then sweep each
row left to right: at each boundary cell, compute the coverage fraction
from traversals and accumulate a winding delta (+1 for upward crossings,
-1 for downward). Between boundary cells, if the winding count is
nonzero, emit an interior run. No flood fill, no dense matrix.</p>
<p>The winding delta computation is simple: if a traversal enters above
the cell’s vertical midpoint and exits below (or vice versa), it
contributes ±1 to the winding count. This is the same ray-casting
principle used in point-in-polygon tests, applied incrementally along
each scanline.</p>
<p><strong>Item 2: Lightweight walk.</strong> The Cell class allocates
heap memory for each cell visit (vectors of traversals, coordinate
lists). For boundary cells this is unavoidable — you need the geometry.
But for the walk itself, most of the Cell machinery (chain lists, area
computation) is unnecessary until the coverage fraction is actually
needed. Replacing Cell with a lightweight <code>LightTraversal</code>
struct and direct <code>Box::crossing()</code> calls eliminated per-cell
allocation overhead.</p>
<p><strong>Item 3: Analytical single-traversal coverage.</strong> About
90% of boundary cells see exactly one traversal — a single edge path
through the cell. For these cells, the coverage fraction can be computed
analytically without the full <code>left_hand_area()</code>
chain-chasing algorithm. The traversal path plus a segment of the cell
perimeter form a simple polygon; its area (via the shoelace formula) is
the coverage fraction.</p>
<p>The subtlety was getting the perimeter walk direction right. After a
traversal exits the cell, the left-hand polygon closes by walking
<em>clockwise</em> along the cell boundary back to the entry point,
collecting cell corners that fall within that arc. The initial
implementation walked counter-clockwise and got complement areas — 0.75
instead of 0.25 for cells where the polygon covers a small corner. The
fix used exactextract’s <code>perimeter_distance()</code> function to
parameterize corner positions along the cell boundary, then selected
corners whose CW distance from the exit fell within the arc to the
entry.</p>
<p><strong>Item 4: O(perimeter) benchmarks.</strong> Systematic timing
across five geometry types (square, sliver, star, donut, jagged
coastline) at six resolutions (100² to 3200²) confirmed the scaling
hypothesis. Scanline time grew linearly with resolution (doubling
resolution roughly doubled time), while the dense algorithm grew
quadratically. At 3200×3200, the star polygon showed a 17× speedup; the
jagged coastline 9×. The advantage grows with resolution — exactly the
regime where sparse output matters most.</p>
<p><strong>Item 5: Shared-boundary complementarity.</strong> Two
adjacent polygons sharing an edge should produce coverage fractions that
sum to exactly 1.0 in every boundary cell, with no gaps and no overlaps.
This property fell out naturally from the algorithm:
<code>Box::crossing()</code> is deterministic for coincident edges,
opposite traversal directions produce complementary left-hand areas, and
independent walks of adjacent polygons produce correct complementarity
without any coordination between them. Validated across 18 test cases
including NC county boundaries.</p>
<p><strong>Item 6: Edge cases.</strong> Vertex on grid node, vertex on
cell edge, horizontal and vertical edges (including on grid lines), thin
slivers (sub-cell thickness), polygons within a single cell,
near-degenerate shapes (acute triangles, needles), extreme resolution
ratios (1×1 to 500×500), polygons extending beyond the grid extent, and
collinear vertices. Twenty-six tests, twenty-five exact matches, one
accepted divergence for invalid overlapping multipolygon geometry.</p>
<p>The extent-clipping fix was the most interesting: a polygon extending
beyond the grid extent has edges in the grid’s “padding columns” — cells
that don’t correspond to any grid column. These edges still carry
winding deltas that affect grid rows. The fix was to allow
padding-column cells to propagate winding into the sweep without
contributing coverage, so the first grid column after a padding boundary
cell correctly begins an interior run.</p>
</div>
<div class="section level3">
<h3 id="coming-home-to-controlledburn">Coming home to controlledburn<a class="anchor" aria-label="anchor" href="#coming-home-to-controlledburn"></a>
</h3>
<p>The final step was migrating the code back to controlledburn — the
package that started this whole line of work. The old Rcpp-based
scanline code was removed entirely, replaced with the new cpp11
implementation. The package name was always right; it just needed better
internals.</p>
<p>controlledburn 0.1.0 exports three functions.
<code><a href="../reference/burn_scanline.html">burn_scanline()</a></code> is the new O(perimeter) algorithm.
<code><a href="../reference/burn_sparse.html">burn_sparse()</a></code> is the exactextract-backed reference
implementation, useful for validation and as a fallback.
<code><a href="../reference/materialise_chunk.html">materialise_chunk()</a></code> expands the sparse output to a dense
matrix — opt-in, when you actually need pixels.</p>
<p>The input interface accepts anything wk can handle:
<code>geos_geometry</code>, <code>sfc</code>, <code><a href="https://paleolimbot.github.io/wk/reference/wkb.html" class="external-link">wk::wkb()</a></code>,
<code>blob</code>, or raw WKB lists from vapour and gdalraster. The grid
specification is extent + dimension, with sensible defaults derived from
the geometry bounding box.</p>
</div>
<div class="section level3">
<h3 id="validation">Validation<a class="anchor" aria-label="anchor" href="#validation"></a>
</h3>
<p>controlledburn was validated against itself (scanline vs sparse
agreement), against the previous controlledburn (interior cell
agreement, boundary disagreements at O(perimeter)), and against a
comprehensive edge-case suite:</p>
<table class="table">
<thead><tr class="header">
<th>Suite</th>
<th>Tests</th>
<th>Status</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Scanline vs sparse</td>
<td>8</td>
<td>all pass (max diff 9.4e-08)</td>
</tr>
<tr class="even">
<td>Shared boundaries</td>
<td>18</td>
<td>all pass (NC counties included)</td>
</tr>
<tr class="odd">
<td>Edge cases</td>
<td>26</td>
<td>25 exact, 1 accepted divergence</td>
</tr>
<tr class="even">
<td>Grid parameters</td>
<td>6</td>
<td>all pass</td>
</tr>
<tr class="odd">
<td>Input types</td>
<td>5</td>
<td>all pass</td>
</tr>
<tr class="even">
<td>Materialisation</td>
<td>4</td>
<td>all pass</td>
</tr>
</tbody>
</table>
<p>The cross-package comparison with the old controlledburn showed zero
cases where the new algorithm missed interior cells that the old one
found. All disagreements were boundary cells — the old algorithm
classified them binary (in/out by cell centre), the new one gives the
exact fraction.</p>
</div>
<div class="section level3">
<h3 id="whats-next">What’s next<a class="anchor" aria-label="anchor" href="#whats-next"></a>
</h3>
<p>The sparse two-table output is the foundation, not the final product.
The immediate next steps:</p>
<p><strong>Materialisation to tiles.</strong>
<code><a href="../reference/materialise_chunk.html">materialise_chunk()</a></code> currently expands to a full-grid
matrix. For large grids, you want to materialise to arbitrary tile
extents — a 256×256 window into a million-cell grid, producing a dense
tile suitable for writing to a GeoTIFF block or feeding into a raster
algebra operation. The sparse output is naturally suited to this: filter
runs and edges to the tile extent, materialise only that window.</p>
<p><strong>Streaming to files.</strong> Combine tiled materialisation
with GDAL write to produce raster files directly from the sparse output,
tile by tile, without holding the full grid in memory. This closes the
loop from polygon to raster file without intermediate dense
allocation.</p>
<p><strong>Multi-polygon fusion.</strong> Given a collection of polygons
with attributes, produce a raster where each cell gets the attribute of
the polygon with the greatest coverage fraction. This is exactextractr’s
<code>rasterize_polygons()</code> but from the sparse intermediate —
faster for repeated rasterizations of the same geometry at different
resolutions.</p>
<p><strong>Raster extraction.</strong> The inverse operation: given a
raster and a set of polygons, use the sparse intersection to extract
weighted cell values. This is what exactextractr does, but the sparse
intermediate can be computed once and reused across multiple rasters on
the same grid.</p>
<p>The sparse polygon-grid intersection is the centre of gravity.
Everything else — rasterization, extraction, overlay, statistics — is a
view onto it. controlledburn computes that intersection once, compactly,
and lets you choose what to do with it.</p>
<p>The code is at <a href="https://github.com/hypertidy/controlledburn" class="external-link">github.com/hypertidy/controlledburn</a>.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

      </div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Michael Sumner, Noam Ross.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.2.0.</p>
</div>

      </footer>
</div>






  </body>
</html>
